trigger:
  - main

pool:
  vmImage: 'ubuntu-latest'

variables:
  imageRepository: 'claimstatusapi'
  tag: '$(Build.BuildId)'
  acrServiceConnection: 'sc-acr-claimstatusapi-3' # ACR service connection name
  acrLoginServer: 'acrclaimstatusapicnalv2intro2b3.azurecr.io'
  armServiceConnection: 'sc-claimstatusapi-3' # Azure Resource Manager service connection name
  resourceGroupName: 'rg-cnalv2-introspect2b-test-3'
  containerAppName: 'claimstatusapi'

resources:
  repositories:
    - repository: self
      type: github
      name: chrisabbotthauxwell/claim-status-api
      ref: main
      endpoint: 'sc-github-chrisabbotthauxwell' # Github service connection name

steps:
  - checkout: self

  - task: DotNetCoreCLI@2
    displayName: 'Run unit tests'
    inputs:
      command: 'test'
      projects: 'src/ClaimStatusAPI.UnitTests/ClaimStatusAPI.UnitTests.csproj'
      arguments: '--configuration Release'

  - task: Docker@2
    displayName: 'Build Docker image'
    inputs:
      containerRegistry: '$(acrServiceConnection)'
      repository: '$(imageRepository)'
      command: build
      Dockerfile: 'src/ClaimStatusAPI/Dockerfile'
      buildContext: 'src/ClaimStatusAPI'
      tags: |
        $(tag)
        latest

  - task: Docker@2
    displayName: 'Push Docker image to ACR'
    inputs:
      containerRegistry: '$(acrServiceConnection)'
      repository: '$(imageRepository)'
      command: push
      tags: |
        $(tag)
        latest

  # Enhanced Trivy scan with JSON output for AI processing
  - script: |
      set -euo pipefail
      echo "Scanning $(acrLoginServer)/$(imageRepository):$(tag) for HIGH/CRITICAL vulnerabilities"
      
      # Run Trivy with JSON output for AI processing
      docker run --rm \
        -v /var/run/docker.sock:/var/run/docker.sock \
        -v "$(System.DefaultWorkingDirectory):/work" \
        aquasec/trivy:latest \
        image --format json -o /work/trivy-results.json \
        --severity HIGH,CRITICAL \
        "$(acrLoginServer)/$(imageRepository):$(tag)" || true
      
      # Also show table format for human readability
      docker run --rm \
        -v /var/run/docker.sock:/var/run/docker.sock \
        aquasec/trivy:latest \
        image --severity HIGH,CRITICAL --format table \
        "$(acrLoginServer)/$(imageRepository):$(tag)" || true
      
      echo ""
      echo "##[warning]Vulnerability scan completed. Review findings above."
        
    displayName: 'Docker image Vulnerability scan'
    workingDirectory: '$(System.DefaultWorkingDirectory)'

  # AI-powered vulnerability remediation suggestions
  - task: AzureCLI@2
    displayName: 'Get AI remediation suggestions for vulnerabilities'
    condition: always() # Run even if previous steps had warnings
    env:
      AZURE_OPENAI_KEY: $(AZURE_OPENAI_KEY)
      AZURE_OPENAI_ENDPOINT: $(AZURE_OPENAI_ENDPOINT)
      OPENAI_MODEL: $(OPENAI_MODEL)
    inputs:
      azureSubscription: '$(armServiceConnection)'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      workingDirectory: '$(System.DefaultWorkingDirectory)'
      inlineScript: |
        set -euo pipefail
        
        model="${OPENAI_MODEL:-gpt-4o-mini}"
        
        # Check if vulnerability results exist
        if [ ! -f "trivy-results.json" ]; then
          echo "No Trivy results found, skipping AI analysis"
          exit 0
        fi
        
        # Extract HIGH/CRITICAL vulnerabilities
        vuln_count=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH" or .Severity=="CRITICAL")] | length' trivy-results.json)
        
        if [ "$vuln_count" -eq 0 ]; then
          echo "No HIGH/CRITICAL vulnerabilities found, skipping AI analysis"
          exit 0
        fi
        
        echo "Found $vuln_count HIGH/CRITICAL vulnerabilities, requesting AI remediation suggestions..."
        
        # Extract vulnerability summary for AI analysis
        vuln_summary=$(jq -r '
          [.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH" or .Severity=="CRITICAL") | 
          {
            VulnerabilityID: .VulnerabilityID,
            PkgName: .PkgName,
            InstalledVersion: .InstalledVersion,
            FixedVersion: .FixedVersion,
            Severity: .Severity,
            Title: .Title,
            Description: .Description
          }] | .[:10] # Limit to first 10 for token efficiency
        ' trivy-results.json)
        
        # Create the prompt for OpenAI
        prompt="You are a security expert. I have a .NET 8 containerized application with the following vulnerabilities detected by Trivy. Please provide specific, actionable remediation steps:

        Container Image: $(acrLoginServer)/$(imageRepository):$(tag)
        Base Image: mcr.microsoft.com/dotnet/aspnet:8.0
        
        Vulnerabilities:
        $vuln_summary
        
        Please provide:
        1. Priority order for fixing these vulnerabilities
        2. Specific remediation steps (package updates, base image changes, etc.)
        3. Any Dockerfile modifications needed
        4. Alternative approaches if direct fixes aren't available
        
        Keep the response concise and actionable for a CI/CD pipeline context."
        
        # Call Azure OpenAI API
        response=$(curl -s -X POST "$AZURE_OPENAI_ENDPOINT/openai/deployments/$model/chat/completions?api-version=2024-08-01-preview" \
          -H "Content-Type: application/json" \
          -H "api-key: $AZURE_OPENAI_KEY" \
          -d "{
            \"messages\": [
              {
                \"role\": \"user\",
                \"content\": $(echo "$prompt" | jq -R -s .)
              }
            ],
            \"max_tokens\": 1500,
            \"temperature\": 0.3
          }")
        
        # Extract and display the AI response
        ai_suggestion=$(echo "$response" | jq -r '.choices[0].message.content // "No response received"')
        
        echo ""
        echo "=============================================================================="
        echo " AI-POWERED VULNERABILITY REMEDIATION SUGGESTIONS"
        echo "=============================================================================="
        echo "$ai_suggestion"
        echo "=============================================================================="
        
        # Also save to artifact for later reference
        echo "$ai_suggestion" > ai-remediation-suggestions.txt
        
        # Check for API errors
        if echo "$response" | jq -e '.error' > /dev/null; then
          echo "##[warning]OpenAI API Error: $(echo "$response" | jq -r '.error.message // "Unknown error"')"
        fi

  - task: AzureCLI@2
    displayName: 'Deploy Docker image to ACA'
    env:
      AZURE_OPENAI_KEY: $(AZURE_OPENAI_KEY)
      AZURE_OPENAI_ENDPOINT: $(AZURE_OPENAI_ENDPOINT)
      OPENAI_MODEL: $(OPENAI_MODEL)
    inputs:
      azureSubscription: '$(armServiceConnection)'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        set -euo pipefail

        # ensure containerapp extension is present
        az extension show -n containerapp >/dev/null 2>&1 || az extension add --name containerapp

        model="${OPENAI_MODEL:-gpt-4o-mini}"
        echo "Using OPENAI_MODEL=$model"

        # store secrets on the Container App (secret names must be lowercase/hyphen)
        az containerapp secret set \
          --name "$(containerAppName)" \
          --resource-group "$(resourceGroupName)" \
          --secrets azure-openai-key="$AZURE_OPENAI_KEY" azure-openai-endpoint="$AZURE_OPENAI_ENDPOINT"

        # set environment variables on the Container App; use @secret-name to reference stored secret
        az containerapp update \
          --name "$(containerAppName)" \
          --resource-group "$(resourceGroupName)" \
          --set-env-vars AZURE_OPENAI_KEY=secretref:azure-openai-key AZURE_OPENAI_ENDPOINT=secretref:azure-openai-endpoint OPENAI_MODEL=${model}

        # update image (this triggers a restart so the new secrets/env take effect)
        az containerapp update \
          --name "$(containerAppName)" \
          --resource-group "$(resourceGroupName)" \
          --image "$(acrLoginServer)/$(imageRepository):$(tag)"